# FitNote 软件设计文档

作者：unixbq

## 一、引言

### 0. 概览

这里是 Fitnote —— 一款带有社交属性的健身微信小程序的项目设计文档。

### 1. 编写目的

1. 展示软件大体框架
2. 展示技术选型的理由与思考
3. 留下一些经验，在每部分技术选型时，对比讲解一些技术。
4. 作业需要

### 2．项目背景

这是一个供微信用户使用的具有社交属性的健身小程序，能够让用户在不下载任何APP的情况下，自由的使用各种有关于运动的功能。随着全民健身上升为国家战略，以及去年马拉松，跑步等赛事的大热兴起，健身己经成为一种新的生活方式，在互联网+的影响下，健身领域也搭上互联网的顺风车。本小程序支持满足用户在健身运动过程中的各种基本需求。同时，通过合理的空间布局和UI设计，给用户带来良好的使用体验，给予用户充足的健身动力。并且支持用户定制自己独有的健身计划，通过由用户自己决定要将哪些运动动作纳入到训练计划当中，以定制化为特色吸引更多用户的使用。另外，根据对市面上已有的健身小程序的分析，我们提出了打造健身&社交的概念，将社交加入健身，打造良好的云健身社区，加强用户之间的互动和深入交流。

## 二、总体设计

![ZuChm6.png](https://s2.ax1x.com/2019/06/27/ZuChm6.png)

前后端分离，同时借助一个跳板请求云服务（MongoDB、mySQL、Redis等服务）。

### 前端（客户端）

#### 技术选型

##### 目标

我们希望该技术可有以下特点：

1. 跨平台，可跨越安卓和IOS平台，降低开发成本降低了门槛

2. 流量大，可借助其流量很好的获得用户，降低获客成本。

3. 成本低，简单，高效的开发，并且分发成本低。

4. 轻应用，无需下载注册，用完即走，不占内存，使服务的途径变得触手可及，简化操作流程。

5. 高体验，响应速度快，功能丰富。

##### 当前解决方案

经过多种方案考察与思考，我们选择了**微信小程序**。

引用一段微信小程序的官方介绍：

> 小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。

与此同时，小程序提供了一个简单、高效的应用开发框架和丰富的组件及API，帮助开发者在微信中开发具有原生 APP 体验的服务。

##### 其他方案与思考

我们有三种方案

1. 原生应用 Native APP
2. 网页应用 Web APP
3. 小程序 Mini Program

对于 Web App：Web App 主要是通过 H5 开发完成的，优势是开发速度快，而且网页版跨平台，一次性开发就能同时适用与安卓和苹果iOS双系统。

对于 Native App：原生App是指利用安卓和苹果iOS官方的开发软件、语音进行编程开发制作，功能上非常丰富，反应速度快、性能高，用户体验非常高。

而小程序兼有两者的优点：

1. 跨平台（对于 iOS 和 Android 两个平台只需要开发一套程序）
2. 具备接近于 Native App 的体验
3. 对原生组件有访问能力
4. 具备缓存能力
5. 上手容易，开发逻辑较为简单

同时，它还有自己独特的特点：

1. 小程序在设计时就做了很多约定式的规
2. 开发环境很干净，无需安装任何除开发工具外的其他的软件
3. 发布和部署流程非常简单，几乎是“傻瓜式”，点击下就可以将应用发布到腾讯云
4. 小程序具有微信天然的关系链与获客能力（这也是小程序最大的优势）

#### 架构设计

前端部分的主要文件结构：

```
.
├── LICENSE
├── README.md
├── app.js
├── app.json
├── app.wxss
├── pages
│   ├── addCounter
│   │   ├── addCounter.js
│   │   └── ······
│   ├── cardDetail
│   │   ├── cardDetail.js
│   │   └── ······
│   ├── counter
│   │   ├── counter.js
│   │   └── ······
│   ├── fit
│   │   ├── fit.js
│   │   └── ······
│   ├── getCard
│   │   ├── getCard.js
│   │   └── ······
│   ├── gymDetail
│   │   ├── gymDetail.js
│   │   └── ······
│   ├── gymNearby
│   │   ├── gymNearby.js
│   │   └── ······
│   ├── index
│   │   ├── index.js
│   │   └── ······
│   ├── me
│   │   ├── me.js
│   │   └── ······
│   └── power
│       ├── power.js
│       └── ······
├── project.config.json
├── sitemap.json
└── utils
    └── util.js
```

#### 模块划分

前端模块主要含有以下部分：

1. 登陆模块
2. 健身模块
3. 通用功能模块

#### 软件设计技术

![ZuCWOx.png](https://s2.ax1x.com/2019/06/27/ZuCWOx.png)

使用MVVM设计模式。MVVM的全称为Model-View-ViewModel，M表示Model，V表示视图View，VM表示数据与模型，当前端View变化时，由于View与VM进行了绑定，VM又与M进行交互，从而使M得到了改变；当M发生变化时，小程序检测到变化并通知VM，由于VM和V进行了绑定，因此V得到改变。

#### 登陆设计

##### 目标

用户登录是大部分完整 App 必备的流程。

一个简单的用户系统需要关注至少这些层面

1. 安全性(加密)
2. 持久化登录态(类似cookie)
3. 登录过期处理
4. 确保用户唯一性, 避免出现多账号
5. 授权
6. 绑定用户昵称头像等信息
7. 绑定手机号(实名和密保方式)

##### 当前解决方案

利用OpenId 创建用户体系。

OpenId 是一个用户对于一个小程序／公众号的标识，开发者可以通过这个标识识别出用户。

##### 其他方案与思考

我们有三种方案

1. 利用现有登录体系
2. 利用 OpenId 创建用户体系
3. 利用 Unionid 创建用户体系

对于利用现有登录体系：直接复用现有系统的登录体系（QQ登陆，微信登录，邮箱登录等），只需要在小程序端设计用户名，密码/验证码输入页面，便可以简便的实现登录，只需要保持良好的用户体验即可。

对于利用 Unionid 创建用户体系：如果想实现多个小程序，公众号，已有登录系统的数据互通，可以通过获取到用户 unionid 的方式建立用户体系。因为 unionid 在同一开放平台下的所所有应用都是相同的，通过 unionid 建立的用户体系即可实现全平台数据的互通，更方便的接入原有的功能。

但是，对于 Unionid 来说，需要获取 unionid 形式的登录体系，在以前（18年4月之前）是通过以下这种方式来实现，但后续微信做了调整（因为一进入小程序，主动弹起各种授权弹窗的这种形式，比较容易导致用户流失），调整为必须使用按钮引导用户主动授权的方式，这次调整对开发者影响较大，开发者需要注意遵守微信的规则，并及时和业务方沟通业务形式，不要存在侥幸心理，以防造成小程序不过审等情况。

```js
wx.login(获取code) ===> wx.getUserInfo(用户授权) ===> 获取 unionid
```

对于利用OpenId 创建用户体系：

OpenId 是一个小程序对于一个用户的标识，利用这一点我们可以轻松的实现一套基于小程序的用户体系，值得一提的是这种用户体系对用户的打扰最低，可以实现静默登录。具体步骤如下：

1. 小程序客户端通过 wx.login 获取 code
2. 传递 code 向服务端，服务端拿到 code 调用微信登录凭证校验接口，微信服务器返回 openid 和会话密钥 session_key ，此时开发者服务端便可以利用 openid 生成用户入库，再向小程序客户端返回自定义登录态
3. 小程序客户端缓存 （通过storage）自定义登录态（token），后续调用接口时携带该登录态作为用户身份标识即可

![ZuCR61.jpg](https://s2.ax1x.com/2019/06/27/ZuCR61.jpg)

#### 小程序工程化

##### 目标

目前的前端开发过程，工程化是必不可少的一环。

我们的目标是解决目前小程序开发当中存在的以下问题：

1. 不支持 css预编译器,作为一种主流的 css解决方案，不论是 less,sass,stylus 都可以提升css效率
2. 不支持引入npm包 （这一条，从微信公开课中听闻，微信准备支持）
3. 不支持ES7等后续的js特性，好用的async await等特性都无法使用
4. 不支持引入外部字体文件，只支持base64
5. 没有 eslint 等代码检查工具

##### 当前解决方案

我们小程序工程化方案选择： gulp。

通过 gulp 的 task 实现：

1. 实时编译 less 文件至相应目录
2. 引入支持async，await的运行时文件
3. 编译字体文件为base64 并生成相应css文件，方便使用
4. 依赖分析哪些地方引用了npm包，将npm包打成一个文件，拷贝至相应目录
5. 检查代码规范

##### 其他方案与思考

对于目前常用的工程化方案，webpack，rollup，parcel等来看，都常用与单页应用的打包和处理，而小程序天生是 “多页应用” 并且存在一些特定的配置。

根据要解决的问题来看，无非是文件的编译，修改，拷贝这些处理，对于这些需求，我们想到基于流的 gulp 非常的适合处理，并且相对于 webpack 配置多页应用更加简单。

### 后端（服务端）

#### 技术选型

##### 目标

我们希望该技术可有以下特点：

1. 单线程，操作系统完全不再有线程创建、销毁的时间开销。

2. 非阻塞I/O，避免I/O阻塞了代码的执行，极大地降低了程序的执行效率。

3. 事件驱动 event-driven，不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，等待调度。

##### 当前解决方案

我们选择了 Node.js 作为我们的后端技术。

原因如下：

1. Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。
2. Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。
3. 在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。
4. Node.js底层是C++。底层代码中，近半数都用于事件队列、回调函数队列的构建。用事件驱动来完成服务器的任务调度。

![ZuC2lR.png](https://s2.ax1x.com/2019/06/27/ZuC2lR.png)


##### 其他方案与思考

Node.js / PHP / JSP

Node.js 不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js 的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。

与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS），Node.js 跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js 的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js 没有web容器。

#### 构架设计

后端的主要文件结构：

```
.
├── LICENSE
├── README.md
├── app.js
├── config
│   └── config.js
├── controllers
│   └── ······
├── cotrollers
│   └── ······
├── models
│   └── ······
├── package.json
└── routes
    ├── index.js
    └── ······
```

#### 模块划分

后端服务模块主要包含：配置模块，路由模块，数据库模块和模版模块。

#### 软件设计技术

洋葱模型原理， 把后一个函数当做参数传递给前一个函数，从而实现把多个函数串起来执行的效果。

![ZuC40K.jpg](https://s2.ax1x.com/2019/06/27/ZuC40K.jpg)

洋葱模式可以拆解成一下几个元素：

1. 生命周期
2. 中间件
3. 中间件在生命周期中
    - 前置操作
    - 等待其他中间件操作
    - 后置操作

#### 框架选择

##### 目标

Nodejs 有许许多多的框架，我们希望该框架有以下特点：

1. 简单灵活，编写舒适方便。
2. 社区支持，有社区的支持，可以快速找到问题解决方案。
3. 扩展性强，可以灵活实现多种需求。

##### 当前解决方案

我们最终选择 Koa 2 作为我们的开发框架。

koa被认为是第二代node web framework，它最大的特点就是独特的中间件流程控制，是一个典型的洋葱模型。koa和koa2中间件的思路是一样的，但是实现方式有所区别，koa2在node7.6之后更是可以直接用async/await来替代generator使用中间件。

![ZuCgp9.png](https://s2.ax1x.com/2019/06/27/ZuCgp9.png)


##### 其他方案与思考

我们有三种方案：

1. Express
2. Koa
3. Hapi

对于 Express：Express是一个最小且灵活的Web应用程序框架，为Web和移动应用程序提供了一组强大的功能，它的行为就像一个中间件，可以帮助管理服务器和路由。但是它有一些影响开发过程的小缺点：

1. 组织需要非常清楚，以避免在维护代码时出现问题
2. 随着代码库大小的增加，重构变得非常具有挑战性
3. 需要大量的手工劳动，因为您需要创建所有端点

对于 Hapi：Hapi是基础功能相对丰富的框架。开发人员更专注于业务，而不是花时间构建基础架构。配置驱动的模式，区别于传统的web服务器操作。他还有比一个独特功能，能够在特定的IP上创建服务器，具有类似的功能onPreHandler。再需要的时候你可以拦截特地的请求做一些必要的操作。但是它有一些影响开发过程的小缺点：

1. 代码结构复杂
2. 插件不兼容，只能使用指定的插件如：catbox joi boom tv good travelogue等
3. 端点是手动创建的，必须手动测试
4. 重构是手动的

对于 Koa：Koa 是一个新的 web 框架，由 Express幕后的原班人马打造，致力于成为web应用和API开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa帮你丢弃回调函数，并有力地增强错误处理Koa并没有捆绑任何中间件而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。

Koa 具有以下特点：

1. Koa提高了互操作性，健壮性，使编写中间件变得更加愉快。
2. 集成了大量的web API，但是没有绑定中间件
3. 非常轻量，核心的Koa模块只有大约2K行代码
4. 拥有非常好的用户体验
5. 通过try / catch更好地处理错误
6. 异步控制流，代码可读性更高
7. Koa本身是一个非常轻量级的框架,可以构建具有出色性能的Web应用程序。代码可读性和维护性都相对较高






